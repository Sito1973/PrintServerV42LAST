 // Endpoint para imprimir con ID num√©rico de impresora - PROCESAMIENTO INMEDIATO
  app.post("/api/print-id", async (req, res) => {
    res.setHeader('Content-Type', 'application/json');

    try {
      // Validar API Key
      const user = await validateApiKey(req, res);
      if (!user) return;

      // Parsear datos
      const printData = numericPrinterJobRequestSchema.parse(req.body);

      // Buscar impresora
      const printer = await storage.getPrinter(printData.printerId);
      if (!printer) {
        return res.status(404).json({ message: "Impresora no encontrada" });
      }

      if (printer.status === 'offline') {
        return res.status(400).json({ message: "Impresora est√° desconectada" });
      }

      // Nombre del documento
      const documentName = printData.documentName || 
        printData.documentUrl.split('/').pop() || 'documento.pdf';

      // Crear trabajo con estado inicial optimizado
      const printJob = await storage.createPrintJob({
        documentUrl: printData.documentUrl,
        documentName,
        printerId: printer.id,
        userId: user.id,
        copies: printData.copies,
        duplex: printData.duplex,
        orientation: printData.orientation
      });

      // PROCESAMIENTO S√çNCRONO INMEDIATO (sin setTimeout)
      // Preparar datos QZ m√≠nimos sin descargar PDF
      const qzData = {
        printer: printer.name,
        data: [{
          type: 'pixel',
          format: 'pdf',
          flavor: 'file', // URL directa
          data: printData.documentUrl,
          options: {
            orientation: printData.orientation || 'portrait',
            copies: printData.copies || 1,
            duplex: printData.duplex || false,
            ignoreTransparency: printData.options?.ignoreTransparency ?? true,
            altFontRendering: printData.options?.altFontRendering ?? true,
            ...(printData.options?.pageRanges && { pageRanges: printData.options.pageRanges }),
            ...(printData.options?.scaleContent !== undefined && { scaleContent: printData.options.scaleContent }),
            ...(printData.options?.rasterize !== undefined && { rasterize: printData.options.rasterize }),
            ...(printData.options?.interpolation && { interpolation: printData.options.interpolation }),
            ...(printData.options?.colorType && { colorType: printData.options.colorType }),
          }
        }],
        config: {
          jobName: `${documentName} - ID: ${printJob.id}`,
          units: 'mm',
          ...(printData.options?.density !== undefined && { density: printData.options.density }),
          ...(printData.options?.colorType && { colorType: printData.options.colorType }),
          ...(printData.options?.interpolation && { interpolation: printData.options.interpolation }),
          ...(printData.options?.scaleContent !== undefined && { scaleContent: printData.options.scaleContent }),
          ...(printData.options?.rasterize !== undefined && { rasterize: printData.options.rasterize }),
        }
      };

      // Configurar m√°rgenes desde la solicitud JSON o usar valores por defecto
      qzData.config.margins = printData.margins || {
        top: 12.7,   // mil√≠metros por defecto (equivalente a 0.5 pulgadas)
        right: 12.7,
        bottom: 12.7,
        left: 12.7
      };

      // Actualizar inmediatamente a listo
      await storage.updatePrintJob(printJob.id, { 
        status: 'ready_for_client',
        qzTrayData: JSON.stringify(qzData)
      });

      // Notificar v√≠a WebSocket SOLO AL USUARIO DUE√ëO
      if (socketServer) {
        const jobData = {
          id: printJob.id,
          documentName,
          documentUrl: printData.documentUrl,
          printerName: printer.name,
          printerUniqueId: printer.uniqueId,
          status: 'ready_for_client',
          copies: printData.copies,
          duplex: printData.duplex,
          orientation: printData.orientation,
          qzTrayData: qzData,
          timestamp: Date.now()
        };

        // Obtener el socket espec√≠fico del usuario
        const userSocketId = (global as any).getUserSocket?.(user.id.toString());

      console.log(`üîç [NOTIF] ========== VERIFICANDO NOTIFICACI√ìN ==========`);
      console.log(`üë§ [NOTIF] Usuario: ${user.username} (ID: ${user.id})`);
      console.log(`üîå [NOTIF] Socket ID obtenido: ${userSocketId || 'NINGUNO'}`);
        // Modificar el siguiente log
        console.log(`‚úÖ [NOTIF] Socket existe seg√∫n getUserSocket: ${userSocketId ? 'S√ç' : 'NO'}`);

        // Modificar la condici√≥n del if
        if (userSocketId) {
        socketServer.to(userSocketId).emit('new-print-job', jobData);
        console.log(`üì° [NOTIF] ‚úÖ Trabajo ${printJob.id} notificado EXITOSAMENTE al usuario ${user.username}`);
      } else {
          console.log(`‚ö†Ô∏è [NOTIF] ‚ùå Usuario ${user.username} NO CONECTADO VIA WEBSOCKET (seg√∫n getUserSocket)`);
        console.log(`üîÑ [NOTIF] Trabajo ${printJob.id} se procesar√° por polling (modo fallback)`);

        // Debug adicional
        const allSockets = Array.from(socketServer.sockets.sockets.keys());
          console.log(`üîß [DEBUG] Sockets activos (momento del fallback): [${allSockets.join(', ')}]`);
        console.log(`üîß [DEBUG] Funci√≥n getUserSocket disponible: ${typeof (global as any).getUserSocket}`);
      }
      }

      // Respuesta inmediata
      res.status(201).json({
        success: true,
        jobId: printJob.id,
        status: 'ready_for_client',
        immediate_processing: true,
        message: 'Documento listo para impresi√≥n inmediata',
        printer: {
          id: printer.id,
          name: printer.name,
          status: printer.status
        }
      });

    } catch (error) {
      console.error("‚ùå Error en /api/print-id:", error);
      handleValidationError(error, res);
    }
  });